{
    "$schema": "https://ui.shadcn.com/schema/registry-item.json",
    "name": "particle-background",
    "type": "registry:ui",
    "title": "Particle Background",
    "description": "A customizable animated particle background with dots and lines, multiple directions, and performance optimizations.",
    "files": [
        {
            "path": "components/ace-ui/ParticleBackground.tsx",
            "type": "registry:ui",
            "target": "components/ui/particle-background.tsx",
            "content": "\"use client\"\n\nimport { useEffect, useRef, useCallback } from \"react\"\n\ninterface Particle {\n    x: number\n    y: number\n    vx: number\n    vy: number\n    size: number\n    opacity: number\n    color: string\n    type: \"dot\" | \"line\"\n    length?: number\n    rotation?: number\n}\n\ninterface ParticleBackgroundProps {\n    // Animation configuration\n    direction?:\n    | \"left-to-right\"\n    | \"right-to-left\"\n    | \"top-to-bottom\"\n    | \"bottom-to-top\"\n    | \"diagonal-tl-br\"\n    | \"diagonal-tr-bl\"\n    speed?: number // Pixels per second\n    maxParticles?: number // Total number of particles\n\n    // Dots configuration\n    dotsEnabled?: boolean\n    dotColor?: string\n    dotSize?: number // Max size for dots\n    dotOpacity?: number\n\n    // Lines configuration (small, horizontal focus)\n    linesEnabled?: boolean\n    lineColor?: string\n    lineWidth?: number // Max width for lines\n    lineLength?: number // Max length for lines\n    lineOpacity?: number\n\n    // Background & Effects\n    backgroundColor?: string // Changed default to transparent\n    glow?: boolean // Adds a subtle glow effect\n    fadeEdges?: boolean // Particles fade out near canvas edges\n}\n\nexport  function ParticleBackground({\n    direction = \"left-to-right\",\n    speed = 50, // Default speed: 50 pixels per second\n    maxParticles = 150, // Increased default particle count\n    dotsEnabled = true,\n    dotColor = \"#a78bfa\", // Purple\n    dotSize = 2,\n    dotOpacity = 0.6,\n    linesEnabled = true,\n    lineColor = \"#60a5fa\", // Blue\n    lineWidth = 1,\n    lineLength = 10,\n    lineOpacity = 0.5,\n    backgroundColor = \"transparent\", // Default to transparent\n    glow = true,\n    fadeEdges = true,\n}: ParticleBackgroundProps) {\n    const canvasRef = useRef<HTMLCanvasElement>(null)\n    const animationFrameId = useRef<number | undefined>(undefined)\n    const particles = useRef<Particle[]>([])\n    const lastFrameTime = useRef<number>(0)\n    const fpsInterval = 1000 / 60 // Target 60 FPS\n\n    // Get velocity based on direction (in pixels per second)\n    const getVelocity = useCallback(() => {\n        const baseSpeed = speed\n        const randomVariation = (Math.random() - 0.5) * (baseSpeed * 0.2) // +/- 20% variation\n\n        switch (direction) {\n            case \"left-to-right\":\n                return { vx: baseSpeed + randomVariation, vy: randomVariation }\n            case \"right-to-left\":\n                return { vx: -baseSpeed + randomVariation, vy: randomVariation }\n            case \"top-to-bottom\":\n                return { vx: randomVariation, vy: baseSpeed + randomVariation }\n            case \"bottom-to-top\":\n                return { vx: randomVariation, vy: -baseSpeed + randomVariation }\n            case \"diagonal-tl-br\":\n                return { vx: baseSpeed * 0.7 + randomVariation, vy: baseSpeed * 0.7 + randomVariation }\n            case \"diagonal-tr-bl\":\n                return { vx: -(baseSpeed * 0.7) + randomVariation, vy: baseSpeed * 0.7 + randomVariation }\n            default:\n                return { vx: baseSpeed + randomVariation, vy: randomVariation }\n        }\n    }, [direction, speed])\n\n    // Create a new particle or reset an existing one\n    const resetParticle = useCallback(\n        (particle: Particle | null, type: \"dot\" | \"line\", canvas: HTMLCanvasElement): Particle => {\n            const { vx, vy } = getVelocity()\n            const margin = 50 // Margin outside canvas to spawn particles\n\n            let x, y\n\n            // Determine spawn point based on direction\n            if (direction === \"left-to-right\" || direction === \"diagonal-tl-br\") {\n                x = -margin\n                y = Math.random() * (canvas.height + 2 * margin) - margin // Random Y across extended height\n            } else if (direction === \"right-to-left\" || direction === \"diagonal-tr-bl\") {\n                x = canvas.width + margin\n                y = Math.random() * (canvas.height + 2 * margin) - margin\n            } else if (direction === \"top-to-bottom\") {\n                x = Math.random() * (canvas.width + 2 * margin) - margin\n                y = -margin\n            } else if (direction === \"bottom-to-top\") {\n                x = Math.random() * (canvas.width + 2 * margin) - margin\n                y = canvas.height + margin\n            } else {\n                // Default to left-to-right if direction is not recognized\n                x = -margin\n                y = Math.random() * canvas.height\n            }\n\n            const newParticle: Particle = {\n                x,\n                y,\n                vx,\n                vy,\n                size: type === \"dot\" ? dotSize * (0.5 + Math.random() * 0.5) : lineWidth,\n                opacity: type === \"dot\" ? dotOpacity : lineOpacity,\n                color: type === \"dot\" ? dotColor : lineColor,\n                type,\n            }\n\n            if (type === \"line\") {\n                newParticle.length = lineLength * (0.5 + Math.random() * 0.5)\n                // Keep lines mostly horizontal for horizontal directions, otherwise random\n                if (direction === \"left-to-right\" || direction === \"right-to-left\") {\n                    newParticle.rotation = (Math.random() - 0.5) * 0.1 // Very slight angle\n                } else {\n                    newParticle.rotation = Math.random() * Math.PI * 2 // Random rotation for other directions\n                }\n            }\n\n            if (particle) {\n                // Update existing particle\n                Object.assign(particle, newParticle)\n                return particle\n            } else {\n                // Create new particle\n                return newParticle\n            }\n        },\n        [direction, getVelocity, dotSize, dotColor, dotOpacity, lineWidth, lineLength, lineColor, lineOpacity],\n    )\n\n    // Initialize or re-initialize particles\n    const initializeParticles = useCallback(() => {\n        const canvas = canvasRef.current\n        if (!canvas) return\n\n        const newParticles: Particle[] = []\n        let currentDotCount = 0\n        let currentLineCount = 0\n\n        // Distribute particles based on enabled types\n        for (let i = 0; i < maxParticles; i++) {\n            let type: \"dot\" | \"line\"\n            if (dotsEnabled && (!linesEnabled || currentDotCount < maxParticles / 2)) {\n                type = \"dot\"\n                currentDotCount++\n            } else if (linesEnabled && (!dotsEnabled || currentLineCount < maxParticles / 2)) {\n                type = \"line\"\n                currentLineCount++\n            } else if (dotsEnabled) {\n                type = \"dot\"\n                currentDotCount++\n            } else if (linesEnabled) {\n                type = \"line\"\n                currentLineCount++\n            } else {\n                // If both are disabled, break\n                break\n            }\n            newParticles.push(resetParticle(null, type, canvas))\n        }\n        particles.current = newParticles\n    }, [maxParticles, dotsEnabled, linesEnabled, resetParticle])\n\n    // Update particle position and reset if off-screen\n    const updateParticle = useCallback(\n        (particle: Particle, canvas: HTMLCanvasElement, deltaTimeInSeconds: number) => {\n            particle.x += particle.vx * deltaTimeInSeconds\n            particle.y += particle.vy * deltaTimeInSeconds\n\n            const margin = 50 // Margin for checking if off-screen\n\n            // Check if particle is off-screen based on its velocity direction\n            let isOffScreen = false\n            if (particle.vx > 0 && particle.x > canvas.width + margin) isOffScreen = true // Moving right\n            if (particle.vx < 0 && particle.x < -margin) isOffScreen = true // Moving left\n            if (particle.vy > 0 && particle.y > canvas.height + margin) isOffScreen = true // Moving down\n            if (particle.vy < 0 && particle.y < -margin) isOffScreen = true // Moving up\n\n            if (isOffScreen) {\n                resetParticle(particle, particle.type, canvas) // Reset in place\n            }\n        },\n        [resetParticle],\n    )\n\n    // Render particle on canvas\n    const renderParticle = useCallback(\n        (ctx: CanvasRenderingContext2D, particle: Particle, canvas: HTMLCanvasElement) => {\n            let currentOpacity = particle.opacity\n\n            // Fade edges effect\n            if (fadeEdges) {\n                const fadeZone = 150 // Pixels from edge to start fading\n                const distanceX = Math.min(particle.x, canvas.width - particle.x)\n                const distanceY = Math.min(particle.y, canvas.height - particle.y)\n                const minDistance = Math.min(distanceX, distanceY)\n\n                if (minDistance < fadeZone) {\n                    currentOpacity *= minDistance / fadeZone\n                }\n            }\n\n            ctx.globalAlpha = currentOpacity\n\n            if (glow) {\n                ctx.shadowColor = particle.color\n                ctx.shadowBlur = particle.type === \"dot\" ? 6 : 3 // More blur for dots\n            }\n\n            ctx.fillStyle = particle.color\n\n            if (particle.type === \"dot\") {\n                ctx.beginPath()\n                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2)\n                ctx.fill()\n            } else {\n                // Render small line\n                ctx.save()\n                ctx.translate(particle.x, particle.y)\n                if (particle.rotation) {\n                    ctx.rotate(particle.rotation)\n                }\n                ctx.fillRect(-particle.length! / 2, -particle.size / 2, particle.length!, particle.size)\n                ctx.restore()\n            }\n\n            if (glow) {\n                ctx.shadowBlur = 0 // Reset shadow for next draw\n            }\n        },\n        [fadeEdges, glow],\n    )\n\n    // Main animation loop\n    const animate = useCallback(\n        (currentTime: number) => {\n            animationFrameId.current = requestAnimationFrame(animate)\n\n            const deltaTime = currentTime - lastFrameTime.current\n            if (deltaTime < fpsInterval) {\n                return // Skip frame if not enough time has passed\n            }\n            lastFrameTime.current = currentTime - (deltaTime % fpsInterval) // Adjust lastFrameTime for consistent FPS\n\n            const canvas = canvasRef.current\n            if (!canvas) return\n\n            const ctx = canvas.getContext(\"2d\")\n            if (!ctx) return\n\n            // Clear canvas\n            ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n            // Update and render particles\n            particles.current.forEach((particle) => {\n                updateParticle(particle, canvas, deltaTime / 1000) // Pass delta in seconds\n                renderParticle(ctx, particle, canvas)\n            })\n        },\n        [fpsInterval, updateParticle, renderParticle],\n    )\n\n    // Handle canvas resizing\n    const handleResize = useCallback(() => {\n        const canvas = canvasRef.current\n        if (!canvas) return\n\n        // Set canvas dimensions to match its display size, considering device pixel ratio\n        const rect = canvas.getBoundingClientRect()\n        canvas.width = rect.width * window.devicePixelRatio\n        canvas.height = rect.height * window.devicePixelRatio\n\n        const ctx = canvas.getContext(\"2d\")\n        if (ctx) {\n            ctx.scale(window.devicePixelRatio, window.devicePixelRatio) // Scale context for high-DPI screens\n        }\n\n        initializeParticles() // Re-initialize particles on resize\n    }, [initializeParticles])\n\n    // Setup and cleanup\n    useEffect(() => {\n        const canvas = canvasRef.current\n        if (!canvas) return\n\n        // Set initial size and add resize listener\n        handleResize()\n        window.addEventListener(\"resize\", handleResize)\n\n        // Start animation loop\n        lastFrameTime.current = performance.now()\n        animationFrameId.current = requestAnimationFrame(animate)\n\n        // Cleanup on unmount\n        return () => {\n            window.removeEventListener(\"resize\", handleResize)\n            if (animationFrameId.current) {\n                cancelAnimationFrame(animationFrameId.current)\n            }\n        }\n    }, [handleResize, animate])\n\n    // Re-initialize particles if props change\n    useEffect(() => {\n        initializeParticles()\n    }, [\n        initializeParticles,\n        direction,\n        speed,\n        maxParticles,\n        dotsEnabled,\n        dotColor,\n        dotSize,\n        dotOpacity,\n        linesEnabled,\n        lineColor,\n        lineWidth,\n        lineLength,\n        lineOpacity,\n        glow,\n        fadeEdges,\n    ])\n\n    return (\n        <div className=\"absolute inset-0 overflow-hidden pointer-events-none\" style={{ backgroundColor }}>\n            <canvas ref={canvasRef} className=\"w-full h-full\" />\n        </div>\n    )\n}"
        }
    ]
}